import * as core from '@actions/core';
import { getOctokitOptions, GitHub } from '@actions/github/lib/utils';
import { Context } from '@actions/github/lib/context';
import { retry } from '@octokit/plugin-retry';
import { throttling } from '@octokit/plugin-throttling';
import { } from '@octokit/types';
import { config } from 'dotenv';
import { readFileSync, statSync, existsSync } from 'fs';
import { resolve, isAbsolute, basename } from 'path';
import { lookup } from 'mime-types';

const context = new Context();

class Tagger {
    public name: string;
    public email: string;
    public date: string;
    constructor() {
        this.name = 'update-existing-release github action';
        this.email = 'none'
        let now = new Date();
        this.date = now.toISOString();
    }
}

/**
 * A nexus for keeping track of, and managing the state of, the connection to Github.
 */
class Connection {
    /**
 * The Octokit Github object, used for most interactions with the server.
 */
    protected github: InstanceType<typeof GitHub>;
    /**
     * The secret token used to authenticate with the server.
     */
    protected token: string = 'unknown-token'
    /**
     * The name of the owner whose repo we are building on.
     */
    protected owner: string = 'unknown-owner';
    /**
     * The name of the repo we are building on.
     */
    protected repo: string = 'unknown-repo';
    /**
     * The git ref that triggered this build.
     */
    protected ref: string = 'unknown-ref';
    /**
     * The friendly, autogenerated name of the release, derived from the git tag that triggered
     * this build.
     */
    protected release: string = 'unknown-release';

    /**
     * The SHA associated with this build.
     */
    protected sha: string = 'unknown-sha';

    /** The tag for the release.  If it does not exist, it will be created.  If it does exist,
     * it will be deleted and recreated.  If not given, it will be set to the same as the
     * name of the release.
     */
    protected tag: string = 'unknown-tag';

    /**
     * The default single-line message for tags created by update-existing-release.
     */
    protected message: string = '';

    /**
     *  The default description body for any created release.
     */
    protected body: string = '';

    /**
     * Is this a draft release?
     */
    protected draft: boolean = false;

    /**
     * Is this a prerelease?
     */
    protected prerelease: boolean = false;

    /**
     * The path to the file to be released.
     */
    protected files: Array<string> = [];

    /**
     * The Github context, useful for establishing the current user and project.
     */
    protected context: Object;

    /**
     * The Github release ID.
     */
    protected id: number = -1;

    /**
     *
     */
    protected uploadUrl: string = null;

    constructor() {
        config();
        this.token = core.getInput('token', { required: true });
        core.setSecret(this.token);
        this.github = new GitHub(getOctokitOptions(
            this.token,
            {
                throttling,
                retry
            }
        ));
        this.context = context;
        [this.owner, this.repo] = process.env.GITHUB_REPOSITORY.split('/')
        this.ref = process.env.GITHUB_REF;
        this.sha = process.env.GITHUB_SHA;
        this.setRelease();
        this.setDraft();
        this.setPrerelease();
        this.setFiles();
        this.setMessage();
        this.setBody();
    }

    /**
     *  Creates a GH tag
     */
    protected async createLightweightTag(tagger: Tagger) {
        return await this.github.rest.git.createTag({
            ...context.repo,
            tag: this.tag,
            message: this.message,
            object: this.sha,
            type: 'commit',
            tagger: tagger
        });
    }

    /**
     *  Creates a new release, and then sets the `id` and `uploadUrl` member
     *  variables
     */
    protected async createRelease() {
        core.startGroup('Creating release ' + this.release + '...')
        let release = await this.github.rest.repos.createRelease(
            {
                ...context.repo,
                tag_name: this.tag,
                name: this.release,
                body: this.body,
                draft: this.draft,
                prerelease: this.prerelease
            }
        );

        core.endGroup();

        this.id = release.data.id;
        this.uploadUrl = release.data.upload_url;
    }

    /**
     *  Update a release's metadata, such as it's id, name, body, draft status,
     *  and whether or not it is a prerelease.
     */
    protected async updateRelease() {
        core.startGroup('Updating release ' + this.release + ' (' + this.id + ') ...')

        // Update release
        await this.github.rest.repos.updateRelease(
            {
                ...context.repo,
                release_id: this.id,
                name: this.release,
                body: this.body,
                draft: this.draft,
                prerelease: this.prerelease
            }
        );

        core.endGroup();
    }

    /**
     *  Creates a tag
     */
    protected async createTag() {
        console.log(`Creating tag '${this.tag}'`)

        let tagger = new Tagger();
        let tagObject = await this.createLightweightTag(tagger);

        await this.github.rest.git.createRef(
            {
                ...context.repo,
                ref: 'refs/tags/' + this.tag,
                sha: tagObject.data.sha
            }
        )

        console.log(`Successfully created tag '${this.tag}'`)
    }

    /**
     *  Deletes assets if they already exist
     */
    protected async deleteAssetsIfTheyExist(shouldDeleteAllExisting: boolean): Promise<boolean> {
        let assets = await this.getReleaseAssets();

        let i = 0;
        for (let asset of assets) {
            let shouldDelete: boolean = shouldDeleteAllExisting;

            if (!shouldDeleteAllExisting) {
                for (let oneFile of this.files) {
                    if (asset.name === basename(oneFile)) {
                        shouldDelete = true;
                    }
                }
            }

            if (shouldDelete) {
                // If we're close to the rate limit, make sure the user knows about it
                if (i++ % 100 == 0) {
                    this.getApiRateLimits();
                }
                core.startGroup('Deleting old release asset ' + asset.name + ' (' + asset.id + ')...');
                await this.github.rest.repos.deleteReleaseAsset(
                    {
                        ...context.repo,
                        asset_id: asset.id
                    }
                )
                result = true;
                core.endGroup();
            }
        }

        return result;
    }

    /**
     *  Returns true if the release exists, else false
     */
    protected async doesReleaseExist(): Promise<boolean> {
        let releases = await this.getReleases();
        return releases.includes(this.release);
    }

    dump(name: string, thing: Object): void {
        console.debug(name + ':' + JSON.stringify(thing));
    }

    /**
     *  Get a list of all currently existing assets of the release.
     */
    protected async getReleaseAssets() {
        core.startGroup('Getting assets for the release...')
        console.debug('Release id: ' + this.id);
        if (this.id < 0)
            return;

        let assets = await this.github.paginate(this.github.rest.repos.listReleaseAssets, {
            ...context.repo,
            release_id: this.id,
        });

        this.dump('assets', assets);
        core.endGroup();
        return assets;
    }

    /**
     *  Attempts to find the ID of the release. Sets the `id` and `uploadUrl`
     *  member variables if found, otherwise throws an error.
     */
    protected async useExistingRelease() {
        core.startGroup('Finding ID of release...')

        if(this.id >= 0){
            this.dump('Using cached', this.id);
            core.endGroup();
            return;
        }

        let releasesObject = await this.github.rest.repos.listReleases({
            ...context.repo,
        });

        for (let release of releasesObject.data) {
            if (release.name == this.release) {
                this.id = release.id;
                this.uploadUrl = release.upload_url;
                return;
            }
        }

        this.dump('releasesObjectData', releasesObject.data);
        core.endGroup();

        throw new Error('could not find id corresponding to release ' + this.release);
    }

    /**
     *  Gets a list of the releases for this repo
     */
    protected async getReleases(): Promise<Array<string>> {
        core.startGroup('Getting list of releases...')
        let releasesObject = await this.github.rest.repos.listReleases({
            ...context.repo,
        });
        let releases: Array<string> = [];
        for (let release of releasesObject.data) {
            releases.push(release.name);
        }
        this.dump('releases', releases);
        core.endGroup();
        return releases;
    }


    /**
     *  Gets a list of the repos
     */
    protected async getRepos() {
        core.startGroup('Getting list of repositories...');
        const allReleases = await this.github.rest.repos.listReleases({
            ...context.repo
        });
        const repos = allReleases.data;
        this.dump('repos', repos);
        core.endGroup();
        return repos;
    }

    /**
     *  Returns details on the current tag, or null if it cannot be found.
     */
    protected async getTag() {
        core.startGroup('Getting list of repo tags...')
        let tagsQuery = await this.github.rest.repos.listTags({ ...context.repo });
        let tags = tagsQuery.data;
        core.endGroup();

        for (let tag of tags) {
            if (tag.name === this.tag) {
                console.log(`Successfully found tag '${this.tag}'`)
                return tag;
            }
        }

        console.log(`Could not find tag '${this.tag}'`)
        return null;
    }

    /**
     *  Entry into the action, this will attempt to upload the releases.
     */
    public async run() {
        try {
            let tag = await this.getTag();

            // Create the tag if necessary
            if (tag === null) {
                await this.createTag();
                tag = await this.getTag();
            }

            if (await this.doesReleaseExist()) {
                await this.useExistingRelease();
            } else {
                await this.createRelease();
            }

            console.debug('Release id: ' + this.id);

            // id is >= 0 iff the release got created properly
            if (this.id >= 0) {
                await this.updateRelease();
                await this.uploadAssets(isTruthyString(core.getInput('replace')));
                if (isTruthyString(core.getInput('updateTag'))) {
                    await this.updateTag();
                }
            }
        } catch (error) {
          this.getApiRateLimits();
          core.setFailed(error.message);
        }
    }

    protected async setBody() {
        this.body = core.getInput('body');
        if (this.body !== '')
            return;
        const commitObject = await this.github.rest.git.getCommit({
            ...context.repo,
            commit_sha: this.sha
        });
        this.body = commitObject.data.message;
    }

    protected setDraft() {
        this.draft = isTruthyString(core.getInput('draft'));
        core.setOutput('draft', this.draft ? 'true' : 'false');
    }

    protected setFiles() {
        let inputFileString: string = core.getInput('files', { required: true });
        let inputFiles: Array<string> = inputFileString.split(/[ ,\r\n\t]+/);
        for (let oneFile of inputFiles) {
            let tryPath: string = oneFile;
            if (!existsSync(tryPath) || !isAbsolute(tryPath)) {
                // go on a path hunt
                tryPath = resolve(process.env.GITHUB_WORKSPACE, oneFile);
                if (!existsSync(tryPath)) {
                    throw new Error(`could not find ${oneFile} as either absolute path or path relative to workspace`);
                }
            }
            if (!existsSync(tryPath)) {
                throw new Error(`could not find file ${tryPath} for release; please provide a full path or path relative to workspace`);
            }
            // Although Windows uses backslashes as separators, Windows can also use forward slashes as separators
            // and this choice is more compatible with cross-platform scripts
            this.files.push(tryPath.replace(/\\/g, '/'));
        }
        core.setOutput('files', JSON.stringify(this.files));
    }

    protected setMessage() {
        let message = core.getInput('message');
        if (message === '') {
            this.message = this.release + ' (automatically created)';
        }
    }

    protected setPrerelease() {
        this.prerelease = !isFalsyString(core.getInput('prerelease'));
        core.setOutput('prerelease', this.prerelease ? 'true' : 'false');
    }

    protected setRelease() {
        this.release = core.getInput('release');
        if (this.release === '') {
            this.release = this.ref;
            /* Convert a git ref to a friendlier looking name */
            this.release = this.release.replace(/refs\//, '');
            this.release = this.release.replace(/heads\//, '');
            this.release = this.release.replace(/tags\//, '');
            this.release = this.release.replace(/\//g, '-');
        }
        this.tag = core.getInput('tag');
        if (this.tag === '') {
            this.tag = this.release;
        }
        if (/[\\?~^:*\[@\s]|^\/.*$|\/$|\/\/|\.\.|\.$/.test(this.tag)) {
            throw new Error("Unsuitable tag name");
        }
        core.setOutput('release', this.release);
        core.setOutput('tag', this.tag);
    }

    /**
     *  Updates a tag
     */
    protected async updateTag() {
        // Update tag
        console.debug('Updating tag ' + this.tag + ' to ' + this.sha);

        await this.github.rest.git.updateRef({
            ...context.repo,
            ref: `tags/${this.tag}`,
            sha: process.env.GITHUB_SHA
        });
    }

    /**
     *  Upload all the release assets, replacing them if necessary.
     */
    protected async uploadAssets(removeFileIfNotOverwritten: boolean) {

        let existingAssets = await this.getReleaseAssets();
        let filesToUpload: string[] = this.files.slice(); // Create a copy of `this.files`

        core.startGroup(`Uploading ${filesToUpload.length} release assets.`);
        let promises = [];
        for (let i = 0; i < filesToUpload.length; i++) {
            let fileToUpload = filesToUpload[i];
            // For each file we want to upload
            // Figure out if the file has already been uploaded (and therefore
            // should first be deleted)
            let assetToDelete = existingAssets.find(asset => asset.name === fileToUpload);
            // Also remove that asset from the existing assets. We'll use the
            // existingAssets array later on to remove all files that weren't
            // overwritten
            existingAssets = existingAssets.filter(asset => asset.name !== fileToUpload)

            // If it has been uploaded, then delete it. If it hasn't been
            // uploaded, then just use an immediately resolving promise to keep
            // our types in check.
            let del_promise = typeof assetToDelete !== "undefined"
              ? this.github.rest.repos.deleteReleaseAsset({
                    ...context.repo, asset_id: assetToDelete.id
                }).then(() => {
                    console.log(`Deleted asset because it will be overwrittten: ${assetToDelete.name} (id ${assetToDelete.id})`)
                })
              : Promise.resolve({})

            // We're going to create a long list of promises, and then `await`
            // all the promises right at the end. Each promise will first
            // delete the asset if it exists, and then it will upload that
            // same asset. In this manner, we're as parallel as possible, while
            // keeping the total downtime of any one asset to a minimum.
            promises.push(
                // First try to delete the file
                del_promise.then(() => {}).then(() => {
                    setTimeout(() => {
                        core.startGroup(`Uploading asset ${fileToUpload}...`)
                        if (i % 10 == 0) { this.getApiRateLimits(); }
                        // Then try to upload the file
                        try {
                            this.github.rest.repos.uploadReleaseAsset({
                                ...context.repo,
                                release_id: this.id,
                                url: this.uploadUrl,
                                headers: {
                                    'content-type': this.getMimeType(fileToUpload),
                                    'content-length': statSync(fileToUpload).size
                                },
                                name: basename(fileToUpload),
                                data: readFileSync(fileToUpload) as any
                            }).then(() => {
                                console.log(`Uploaded asset ${fileToUpload}.`)
                            });
                        } catch (error) {
                            this.getApiRateLimits();
                            console.warn(error.message);
                        }
                        core.endGroup()
                    }, 500)
                })
            )
        }
        if (removeFileIfNotOverwritten) {
            for (let asset of existingAssets) {
                promises.push(
                    setTimeout(() => {
                        try {
                            this.github.rest.repos.deleteReleaseAsset({
                                ...context.repo,
                                asset_id: asset.id
                            }).then(() => {
                                console.log(`Deleted asset because it wasn't in the new release: ${asset.name} (id ${asset.id})`)
                            })
                        } catch (error) {
                            this.getApiRateLimits();
                            console.warn(error.message);
                        }
                    }, 500)
                );
            }
        }
        await Promise.all(promises);
        core.endGroup();
    }

    /**
     *  Get the Rate limits for the GitHub API and report them.
     */
    protected async getApiRateLimits() {
        let limits = await this.github.rest.rateLimit.get({
            ...context.repo,
        });
        const core_limits = limits.data.resources.core;
        const reset_at = new Date(core_limits.reset * 1000);
        console.debug(`API Rate Limits: ${JSON.stringify(core_limits)}, reset at: ${reset_at}`);
        return limits.data ?? limits;
    }

    protected getMimeType(file: string) {
        // if we can't figure out what file type you have, we'll assign it this unknown type
        // https://www.iana.org/assignments/media-types/application/octet-stream
        const defaultMimeType = 'application/octet-stream';
        let mimeType: string | false = lookup(file);
        if (mimeType == false) {
            console.warn('content type for file ' + file +
                ' could not be automatically determined from extension; going with ' +
                defaultMimeType);
            mimeType = defaultMimeType;
        }
        return mimeType
    }
}

function isTruthyString(string: String) {
    return string === 'true' || string == 'yes';
}

function isFalsyString(string: String) {
    return string === 'false' || string == 'no';
}

core.startGroup('Updating release...');
let connection = new Connection();
connection.run();
core.endGroup();
